name: Deploy Integrated App (Frontend + Backend)

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'frontend/**'
      - '.github/workflows/deploy-integrated.yml'
      - 'scripts/deploy-integrated-app.sh'
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: gaitanalysisapp
  RESOURCE_GROUP: gait-analysis-rg-wus3
  ACR_NAME: gaitacr737
  IMAGE_NAME: gait-integrated
  IMAGE_TAG: ${{ github.sha }}
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Build frontend
      run: |
        echo "ğŸ“¦ Building frontend..."
        cd frontend
        
        # Check if package.json exists
        if [ ! -f "package.json" ]; then
          echo "âŒ Error: package.json not found!"
          exit 1
        fi
        
        # Install dependencies
        echo "ğŸ“¥ Installing dependencies..."
        npm ci || {
          echo "âŒ Error: npm ci failed!"
          echo "   Trying npm install as fallback..."
          npm install || exit 1
        }
        
        # Build frontend
        echo "ğŸ”¨ Building frontend..."
        npm run build || {
          echo "âŒ Error: Frontend build failed!"
          echo "   Check the build logs above for details"
          exit 1
        }
        
        # Verify build output
        if [ ! -d "dist" ]; then
          echo "âŒ Error: Frontend build output (dist/) not found!"
          exit 1
        fi
        if [ ! -f "dist/index.html" ]; then
          echo "âŒ Error: dist/index.html not found!"
          exit 1
        fi
        
        echo "âœ… Frontend built successfully"
        
    - name: Copy frontend to backend
      run: |
        echo "ğŸ“‹ Copying frontend build to backend..."
        rm -rf backend/frontend-dist
        cp -r frontend/dist backend/frontend-dist
        echo "âœ… Frontend copied to backend/frontend-dist"
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        # Note: No pip cache needed - Python packages are installed inside Docker, not in workflow
        
    - name: Log in to Azure
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Verify Azure resources exist
      run: |
        echo "ğŸ” Verifying Azure resources..."
        
        # Check Resource Group
        if ! az group show --name ${{ env.RESOURCE_GROUP }} &>/dev/null; then
          echo "âŒ Error: Resource group '${{ env.RESOURCE_GROUP }}' not found!"
          exit 1
        fi
        echo "âœ… Resource group exists"
        
        # Check App Service
        if ! az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
          echo "âŒ Error: App Service '${{ env.AZURE_WEBAPP_NAME }}' not found!"
          exit 1
        fi
        echo "âœ… App Service exists"
        
        # Check ACR
        if ! az acr show --name ${{ env.ACR_NAME }} &>/dev/null; then
          echo "âŒ Error: ACR '${{ env.ACR_NAME }}' not found!"
          exit 1
        fi
        echo "âœ… ACR exists"
        
        echo "âœ… All Azure resources verified"
        
    - name: Log in to Azure Container Registry
      run: |
        az acr login --name ${{ env.ACR_NAME }}
        
    - name: Verify Dockerfile exists
      run: |
        if [ ! -f "backend/Dockerfile.integrated" ]; then
          echo "âŒ Error: Dockerfile.integrated not found!"
          exit 1
        fi
        echo "âœ… Dockerfile.integrated found"
        
    - name: Verify frontend build exists
      run: |
        echo "ğŸ” Verifying frontend build..."
        if [ ! -d "backend/frontend-dist" ] || [ ! -f "backend/frontend-dist/index.html" ]; then
          echo "âŒ Error: frontend-dist directory or index.html not found!"
          echo "   This should not happen - frontend should have been built in previous steps"
          echo "   Checking what exists:"
          ls -la backend/ | grep frontend || echo "   No frontend-related files found"
          exit 1
        fi
        echo "âœ… Frontend build verified"
        echo "   Location: backend/frontend-dist/"
        echo "   Files: $(ls -la backend/frontend-dist/ | head -5)"
        
    - name: Verify cleaned code before build
      continue-on-error: true
      run: |
        echo "ğŸ” Verifying cleaned code structure..."
        cd backend
        
        # Verify old files are deleted (non-blocking - just a warning)
        if [ -f "app/api/v1/analysis.py" ]; then
          echo "âš ï¸  Warning: Old analysis.py still exists (non-blocking)"
        fi
        if [ -f "app/api/v1/health.py" ]; then
          echo "âš ï¸  Warning: Old health.py still exists (non-blocking)"
        fi
        if [ -f "app/api/v1/reports.py" ]; then
          echo "âš ï¸  Warning: Old reports.py still exists (non-blocking)"
        fi
        
        # Verify __init__.py doesn't import old files
        if grep -q "from app.api.v1 import analysis, health, reports" app/api/v1/__init__.py 2>/dev/null; then
          echo "âš ï¸  Warning: __init__.py may import deleted files (non-blocking)"
        fi
        
        # Verify only Azure-native files exist
        echo "âœ… Code structure verified (warnings are non-blocking)"
        
    - name: Build and push Docker image to ACR
      run: |
        echo "ğŸ³ Building Docker image (Frontend + Backend)..."
        
        # Verify backend directory exists and change to it
        echo "ğŸ“‚ Checking working directory..."
        echo "   Current directory: $(pwd)"
        echo "   Contents: $(ls -d */ 2>/dev/null | head -5 || echo 'No subdirectories')"
        
        if [ ! -d "backend" ]; then
          echo "âŒ Error: backend directory not found!"
          echo "   Current directory: $(pwd)"
          echo "   Full contents:"
          ls -la
          exit 1
        fi
        
        echo "âœ… backend directory found"
        cd backend || {
          echo "âŒ Error: Failed to change to backend directory"
          echo "   Current directory: $(pwd)"
          exit 1
        }
        
        echo "âœ… Changed to backend directory: $(pwd)"
        
        # Verify required files exist
        echo "ğŸ“‹ Verifying required files..."
        echo ""
        echo "Checking Dockerfile..."
        if [ ! -f "Dockerfile.integrated" ]; then
          echo "âŒ Error: Dockerfile.integrated not found!"
          exit 1
        fi
        echo "âœ… Dockerfile.integrated exists"
        
        echo ""
        echo "Checking main_integrated.py..."
        if [ ! -f "main_integrated.py" ]; then
          echo "âŒ Error: main_integrated.py not found!"
          exit 1
        fi
        echo "âœ… main_integrated.py exists"
        
        echo ""
        echo "Checking requirements.txt..."
        if [ ! -f "requirements.txt" ]; then
          echo "âŒ Error: requirements.txt not found!"
          exit 1
        fi
        echo "âœ… requirements.txt exists"
        
        echo ""
        echo "Checking frontend build..."
        if [ ! -d "frontend-dist" ]; then
          echo "âŒ Error: frontend-dist directory not found!"
          exit 1
        fi
        if [ ! -f "frontend-dist/index.html" ]; then
          echo "âŒ Error: frontend-dist/index.html not found!"
          exit 1
        fi
        echo "âœ… frontend-dist/index.html exists"
        
        if [ -d "frontend-dist/assets" ]; then
          echo "âœ… frontend-dist/assets directory exists"
          ls -la frontend-dist/assets/ | head -5
        else
          echo "âš ï¸  Warning: frontend-dist/assets directory not found (may be empty)"
        fi
        
        echo ""
        echo "Checking app directory structure..."
        if [ ! -d "app" ]; then
          echo "âŒ Error: app directory not found!"
          exit 1
        fi
        echo "âœ… app directory exists"
        
        echo ""
        echo "All required files verified!"
        
        # Verify we're in the backend directory
        if [ ! -f "Dockerfile.integrated" ]; then
          echo "âŒ Error: Not in backend directory! Dockerfile.integrated not found in $(pwd)"
          echo "   Current directory contents: $(ls -la | head -10)"
          exit 1
        fi
        
        # Build image using ACR Tasks
        echo "ğŸ”¨ Starting Docker build..."
        echo "   Registry: ${{ env.ACR_NAME }}"
        echo "   Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo "   Dockerfile: Dockerfile.integrated"
        echo "   Working directory: $(pwd)"
        echo ""
        
        # Set build arguments for traceability
        BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
        GIT_COMMIT="${{ github.sha }}"
        BUILD_VERSION="${{ github.run_number }}"
        
        echo "ğŸ“¦ Build information:"
        echo "   Build Date: $BUILD_DATE"
        echo "   Git Commit: $GIT_COMMIT"
        echo "   Build Version: $BUILD_VERSION"
        echo ""
        
        # Use ACR build cache for faster builds
        # ACR automatically caches Docker layers - unchanged layers are reused
        # This significantly speeds up builds when only code changes
        # System deps and pip packages are cached if requirements.txt unchanged
        # CRITICAL: Build context is the backend directory (.)
        # This ensures requirements.txt, Dockerfile.integrated, and all app files are in the build context
        echo "ğŸ” Build context verification:"
        echo "   Current directory: $(pwd)"
        echo "   Dockerfile exists: $([ -f Dockerfile.integrated ] && echo 'YES' || echo 'NO')"
        echo "   requirements.txt exists: $([ -f requirements.txt ] && echo 'YES' || echo 'NO')"
        echo "   main_integrated.py exists: $([ -f main_integrated.py ] && echo 'YES' || echo 'NO')"
        echo "   app/ directory exists: $([ -d app ] && echo 'YES' || echo 'NO')"
        echo "   frontend-dist/ exists: $([ -d frontend-dist ] && echo 'YES' || echo 'NO')"
        
        if ! az acr build \
          --registry ${{ env.ACR_NAME }} \
          --image ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
          --image ${{ env.IMAGE_NAME }}:latest \
          --file Dockerfile.integrated \
          --build-arg BUILD_DATE="$BUILD_DATE" \
          --build-arg GIT_COMMIT="$GIT_COMMIT" \
          --build-arg BUILD_VERSION="$BUILD_VERSION" \
          .; then
          echo ""
          echo "âŒ Docker build failed!"
          echo "   Check the logs above for the specific error"
          echo "   Common issues:"
          echo "   - Missing files (requirements.txt, main_integrated.py, etc.)"
          echo "   - Frontend build not found (frontend-dist/)"
          echo "   - Dockerfile syntax errors"
          echo "   - ACR authentication issues"
          echo "   - Dependencies not installed (check pip install logs)"
          exit 1
        fi
          
        echo "âœ… Docker image built and pushed to ACR"
        echo "   Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo "   Also tagged as: ${{ env.IMAGE_NAME }}:latest"
        echo "   Build Date: $BUILD_DATE"
        echo "   Git Commit: $GIT_COMMIT"
        
    - name: Get ACR credentials
      id: acr-creds
      run: |
        ACR_LOGIN=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer -o tsv)
        ACR_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
        ACR_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value -o tsv)
        
        echo "login_server=$ACR_LOGIN" >> $GITHUB_OUTPUT
        echo "username=$ACR_USER" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASS" >> $GITHUB_OUTPUT
        
    - name: Configure App Service container
      run: |
        echo "âš™ï¸  Configuring App Service container..."
        echo "   Using image: ${{ steps.acr-creds.outputs.login_server }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        
        # Stop the app first to ensure clean restart
        echo "ğŸ›‘ Stopping App Service..."
        az webapp stop \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --output none || echo "   (App may already be stopped)"
        
        # Configure container with new image
        az webapp config container set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --docker-custom-image-name "${{ steps.acr-creds.outputs.login_server }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" \
          --docker-registry-server-url "https://${{ steps.acr-creds.outputs.login_server }}" \
          --docker-registry-server-user "${{ steps.acr-creds.outputs.username }}" \
          --docker-registry-server-password "${{ steps.acr-creds.outputs.password }}" \
          --output none
        
        # Also set password via app settings (backup method)
        az webapp config appsettings set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --settings DOCKER_REGISTRY_SERVER_PASSWORD="${{ steps.acr-creds.outputs.password }}" \
          --output none
        
        echo "âœ… Container configuration updated"
        
        # Force container to pull new image by setting an environment variable
        # This ensures Azure pulls the latest image even if tag is 'latest'
        echo "ğŸ”„ Forcing container to pull new image..."
        az webapp config appsettings set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --settings \
            DOCKER_IMAGE_TAG="${{ env.IMAGE_TAG }}" \
            DEPLOYMENT_TIMESTAMP="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
          --output none
        
        echo "âœ… Image pull forced with deployment timestamp"
        
    - name: Configure App Service settings
      run: |
        echo "âš™ï¸  Configuring App Service settings..."
        
        # Get Azure service credentials
        echo "ğŸ” Finding Azure resources..."
        STORAGE_ACCOUNT=$(az storage account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?contains(name, 'gait')].name" -o tsv | head -1)
        CV_NAME=$(az cognitiveservices account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?kind=='ComputerVision'].name" -o tsv | head -1)
        SQL_SERVER=$(az sql server list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?contains(name, 'gait')].name" -o tsv | head -1)
        
        echo "   Storage Account: ${STORAGE_ACCOUNT:-'NOT FOUND'}"
        echo "   Computer Vision: ${CV_NAME:-'NOT FOUND'}"
        echo "   SQL Server: ${SQL_SERVER:-'NOT FOUND'}"
        echo ""
        
        if [ -n "$STORAGE_ACCOUNT" ] && [ -n "$CV_NAME" ] && [ -n "$SQL_SERVER" ]; then
          echo "âœ… All Azure services found - configuring environment variables..."
          STORAGE_CONN=$(az storage account show-connection-string --name "$STORAGE_ACCOUNT" --resource-group ${{ env.RESOURCE_GROUP }} --query connectionString -o tsv)
          CV_KEY=$(az cognitiveservices account keys list --name "$CV_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query key1 -o tsv)
          CV_ENDPOINT=$(az cognitiveservices account show --name "$CV_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query properties.endpoint -o tsv)
          
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --settings \
              WEBSITES_PORT=8000 \
              CORS_ORIGINS="https://gentle-sky-0a498ab1e.4.azurestaticapps.net,https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net,http://localhost:3000,http://localhost:5173" \
              AZURE_STORAGE_CONNECTION_STRING="$STORAGE_CONN" \
              AZURE_STORAGE_CONTAINER_NAME="videos" \
              AZURE_COMPUTER_VISION_KEY="$CV_KEY" \
              AZURE_COMPUTER_VISION_ENDPOINT="$CV_ENDPOINT" \
              AZURE_SQL_SERVER="$SQL_SERVER.database.windows.net" \
              AZURE_SQL_DATABASE="gaitanalysis" \
              AZURE_SQL_USER="gaitadmin" \
              AZURE_SQL_PASSWORD="${{ secrets.AZURE_SQL_PASSWORD }}" \
            --output none
        else
          echo "âš ï¸  Some Azure services not found - setting basic configuration only"
          echo "   The app will run with mock services until Azure resources are created"
          echo ""
          # Set basic settings even if services don't exist
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --settings \
              WEBSITES_PORT=8000 \
              CORS_ORIGINS="https://gentle-sky-0a498ab1e.4.azurestaticapps.net,https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net,http://localhost:3000,http://localhost:5173" \
            --output none
        fi
        
        # Enable Always-On
        az webapp config set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --always-on true \
          --output none
        
        # HIGH AVAILABILITY: Configure for maximum availability
        echo "ğŸš€ Configuring high availability settings..."
        
        # Enable HTTP 2.0 for better performance
        az webapp config set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --http20-enabled true \
          --output none
        
        # Set health check path (using generic-configurations for newer API)
        az webapp config update \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --set healthCheckPath="/health" \
          --output none 2>/dev/null || echo "   (Health check may already be configured)"
        
        # Set request timeout via app settings (for long-running video processing and large file uploads)
        # WEBSITES_CONTAINER_START_TIME_LIMIT: Container startup timeout (default: 230s)
        # SCM_COMMAND_IDLE_TIMEOUT: SCM command timeout (default: 230s)
        # WEBSITES_HTTP_LOGGING_RETENTION_DAYS: Log retention (optional)
        # CRITICAL: Azure App Service has a default request timeout of 230 seconds
        # For large video uploads, we need to increase this via web.config or app settings
        # Note: The actual request timeout is controlled by Azure's load balancer (230s default)
        # We can't change it via app settings, but we can optimize the upload process
        az webapp config appsettings set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --settings \
            WEBSITES_WORKER_PROCESSES=1 \
            WEBSITES_CONTAINER_START_TIME_LIMIT=600 \
            SCM_COMMAND_IDLE_TIMEOUT=600 \
          --output none
        
        # CRITICAL: Configure request timeout via web.config
        # Azure App Service uses web.config to set request timeout
        # This allows large file uploads to complete without timing out
        echo "ğŸ“ Configuring request timeout for large file uploads..."
        az webapp config set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --generic-configurations '{"requestTimeout": "00:10:00"}' \
          --output none || echo "âš ï¸  Could not set request timeout (may require web.config file)"
        
        echo "âœ… High availability settings configured"
        
    - name: Restart App Service
      run: |
        echo "ğŸ”„ Starting App Service with new container..."
        az webapp start \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --output none
        
        echo "âœ… App Service started"
        echo "â³ Waiting 10 seconds for initial startup..."
        sleep 10
        
        # Verify the app is running
        STATE=$(az webapp show \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query state -o tsv)
        echo "   App Service state: $STATE"
        
        if [ "$STATE" != "Running" ]; then
          echo "âš ï¸  App Service is not in Running state, attempting restart..."
          az webapp restart \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --output none
          sleep 30
        fi
        
    - name: Wait for container to be ready
      run: |
        echo "â³ Waiting for container to be fully ready..."
        echo "   This may take 20-40 seconds for the first request"
        sleep 20
        
    - name: Verify deployed code
      run: |
        echo "ğŸ” Verifying deployed code..."
        APP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        
        # Check if we can get a response (even if 500, means code is running)
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$APP_URL/" || echo "000")
        echo "   Initial response: HTTP $HTTP_CODE"
        
        if [ "$HTTP_CODE" = "000" ]; then
          echo "   âš ï¸  App not responding yet, will retry in health check"
        else
          echo "   âœ… App is responding (code may still be deploying)"
        fi
    
    - name: Health check
      continue-on-error: true
      run: |
        echo "ğŸ§ª Testing application health..."
        APP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        
        echo "ğŸ“ Testing endpoints:"
        echo "   - $APP_URL/"
        echo "   - $APP_URL/health"
        echo ""
        
        HEALTH_CHECK_PASSED=false
        LAST_ERROR=""
        # Optimized: 10 checks with 5 second intervals = max 50 seconds (was 15 checks * 8s = 120s)
        for i in {1..10}; do
          # Test root endpoint
          HTTP_CODE_ROOT=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$APP_URL/" 2>&1 | tail -1 || echo "000")
          # Test health endpoint  
          HTTP_CODE_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$APP_URL/health" 2>&1 | tail -1 || echo "000")
          
          # Check for specific error patterns in response (only on first few attempts to save time)
          if [ "$i" -le 3 ]; then
            RESPONSE=$(curl -s --max-time 10 "$APP_URL/" 2>&1 || echo "")
            ERROR_RESPONSE=$(curl -s --max-time 10 "$APP_URL/health" 2>&1 || echo "")
            
            # Detect common deployment errors
            if echo "$RESPONSE $ERROR_RESPONSE" | grep -qi "FileResponse.*not defined\|NameError.*FileResponse"; then
              LAST_ERROR="FileResponse import missing - deployment may not have updated. Code needs to be rebuilt."
              echo "   âŒ Check $i/10... Found FileResponse error - code may not be updated"
            elif echo "$RESPONSE $ERROR_RESPONSE" | grep -qi "No module named 'fastapi'\|ModuleNotFoundError.*fastapi"; then
              LAST_ERROR="FastAPI not installed - dependencies may not have been installed during Docker build. Check Dockerfile and requirements.txt."
              echo "   âŒ Check $i/10... Found FastAPI import error - dependencies not installed"
            elif echo "$RESPONSE $ERROR_RESPONSE" | grep -qi "No module named\|ModuleNotFoundError"; then
              LAST_ERROR="Python module not found - check Dockerfile pip install step and requirements.txt"
              echo "   âŒ Check $i/10... Found module import error"
              echo "   This indicates the old code is still running. The new image may not have been pulled."
              if [ "$i" -eq 3 ]; then
                echo "   ğŸ”„ Attempting to force container restart..."
                az webapp restart \
                  --name ${{ env.AZURE_WEBAPP_NAME }} \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --output none
                sleep 15
              fi
            elif echo "$RESPONSE $ERROR_RESPONSE" | grep -qi "500\|Internal Server Error"; then
              if [ -z "$LAST_ERROR" ]; then
                LAST_ERROR="Application error detected (HTTP 500)"
              fi
              echo "   âš ï¸  Check $i/10... Application error (HTTP $HTTP_CODE_ROOT)"
            fi
          fi
          
          if [ "$HTTP_CODE_ROOT" = "200" ] || [ "$HTTP_CODE_HEALTH" = "200" ]; then
            echo ""
            echo "âœ…âœ…âœ… Application is healthy!"
            echo "   Root endpoint: HTTP $HTTP_CODE_ROOT"
            echo "   Health endpoint: HTTP $HTTP_CODE_HEALTH"
            echo ""
            
            # Show health check details
            curl -s --max-time 10 "$APP_URL/health" | python3 -m json.tool 2>/dev/null || \
            curl -s --max-time 10 "$APP_URL/" | python3 -m json.tool 2>/dev/null || \
            echo "   (Response received but not JSON)"
            
            echo ""
            echo "ğŸ”— Application URL: $APP_URL"
            echo "âœ… Integrated deployment successful!"
            HEALTH_CHECK_PASSED=true
            break
          else
            echo "   Check $i/10... (Root: $HTTP_CODE_ROOT, Health: $HTTP_CODE_HEALTH)"
            if [ "$i" -eq 5 ]; then
              echo "   â³ Still starting... this is normal, container may need more time"
            fi
            if [ "$i" -lt 10 ]; then
              sleep 5
            fi
          fi
        done
        
        if [ "$HEALTH_CHECK_PASSED" = "false" ]; then
          echo ""
          echo "âš ï¸  Application health check did not pass within timeout"
          echo "   Final status: Root=$HTTP_CODE_ROOT, Health=$HTTP_CODE_HEALTH"
          if [ -n "$LAST_ERROR" ]; then
            echo "   Error detected: $LAST_ERROR"
          fi
          echo ""
          echo "   This may indicate:"
          echo "   - Container is still starting (wait 2-3 more minutes)"
          echo "   - Code deployment issue (check if new code is in image)"
          echo "   - Application error (check logs below)"
          echo ""
          echo "   Check Azure Portal logs:"
          echo "   https://portal.azure.com/#@/resource/subscriptions/*/resourceGroups/${{ env.RESOURCE_GROUP }}/providers/Microsoft.Web/sites/${{ env.AZURE_WEBAPP_NAME }}/logStream"
          echo ""
          echo "   Or check logs with:"
          echo "   az webapp log tail --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }}"
          exit 1
        fi

    - name: Deployment summary
      if: always()
      run: |
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“Š DEPLOYMENT SUMMARY"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "ğŸ”— Application URL:"
        echo "   https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        echo ""
        echo "ğŸ“¦ Docker Image:"
        echo "   ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo ""
        echo "ğŸ” Azure Resources:"
        echo "   Resource Group: ${{ env.RESOURCE_GROUP }}"
        echo "   App Service: ${{ env.AZURE_WEBAPP_NAME }}"
        echo "   ACR: ${{ env.ACR_NAME }}"
        echo ""
        echo "ğŸ“ Useful Commands:"
        echo "   View logs: az webapp log tail --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }}"
        echo "   Check status: az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query state"
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""


