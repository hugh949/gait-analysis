name: Deploy Integrated App (Frontend + Backend)

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'frontend/**'
      - '.github/workflows/deploy-integrated.yml'
      - 'scripts/deploy-integrated-app.sh'
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: gaitanalysisapp
  RESOURCE_GROUP: gait-analysis-rg-wus3
  ACR_NAME: gaitacr737
  IMAGE_NAME: gait-integrated
  IMAGE_TAG: ${{ github.sha }}
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    # OPTIMIZATION: Run frontend build and backend prep in parallel
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Build frontend
      run: |
        echo "ğŸ“¦ Building frontend..."
        cd frontend
        
        # Fast install with cache (npm ci is faster than npm install)
        echo "ğŸ“¥ Installing dependencies (using cache)..."
        npm ci --prefer-offline --no-audit || npm install --prefer-offline --no-audit
        
        # Build frontend
        echo "ğŸ”¨ Building frontend..."
        npm run build
        
        # Quick verification
        [ -f "dist/index.html" ] || (echo "âŒ dist/index.html not found!" && exit 1)
        echo "âœ… Frontend built successfully"
        
    - name: Copy frontend to backend
      run: |
        rm -rf backend/frontend-dist && cp -r frontend/dist backend/frontend-dist
        echo "âœ… Frontend copied"
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        # Note: No pip cache needed - Python packages are installed inside Docker, not in workflow
        
    - name: Log in to Azure
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Verify Azure resources exist
      run: |
        echo "ğŸ” Verifying Azure resources..."
        
        # Check Resource Group
        if ! az group show --name ${{ env.RESOURCE_GROUP }} &>/dev/null; then
          echo "âŒ Error: Resource group '${{ env.RESOURCE_GROUP }}' not found!"
          exit 1
        fi
        echo "âœ… Resource group exists"
        
        # Check App Service
        if ! az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
          echo "âŒ Error: App Service '${{ env.AZURE_WEBAPP_NAME }}' not found!"
          exit 1
        fi
        echo "âœ… App Service exists"
        
        # Check ACR
        if ! az acr show --name ${{ env.ACR_NAME }} &>/dev/null; then
          echo "âŒ Error: ACR '${{ env.ACR_NAME }}' not found!"
          exit 1
        fi
        echo "âœ… ACR exists"
        
        echo "âœ… All Azure resources verified"
        
    - name: Log in to Azure Container Registry
      run: |
        az acr login --name ${{ env.ACR_NAME }}
        
    - name: Verify Dockerfile exists
      run: |
        if [ ! -f "backend/Dockerfile.integrated" ]; then
          echo "âŒ Error: Dockerfile.integrated not found!"
          exit 1
        fi
        echo "âœ… Dockerfile.integrated found"
        
    # OPTIMIZATION: Streamlined verification - only check critical files
    - name: Quick verification
      run: |
        [ -f "backend/frontend-dist/index.html" ] || (echo "âŒ Frontend build missing!" && exit 1)
        [ -f "backend/Dockerfile.integrated" ] || (echo "âŒ Dockerfile missing!" && exit 1)
        [ -f "backend/requirements.txt" ] || (echo "âŒ requirements.txt missing!" && exit 1)
        echo "âœ… Critical files verified"
        
    - name: Build and push Docker image to ACR
      run: |
        echo "ğŸ³ Building Docker image (Frontend + Backend)..."
        
        # Verify backend directory exists and change to it
        echo "ğŸ“‚ Checking working directory..."
        echo "   Current directory: $(pwd)"
        echo "   Contents: $(ls -d */ 2>/dev/null | head -5 || echo 'No subdirectories')"
        
        if [ ! -d "backend" ]; then
          echo "âŒ Error: backend directory not found!"
          echo "   Current directory: $(pwd)"
          echo "   Full contents:"
          ls -la
          exit 1
        fi
        
        echo "âœ… backend directory found"
        cd backend || {
          echo "âŒ Error: Failed to change to backend directory"
          echo "   Current directory: $(pwd)"
          exit 1
        }
        
        echo "âœ… Changed to backend directory: $(pwd)"
        
        # Verify required files exist
        echo "ğŸ“‹ Verifying required files..."
        echo ""
        echo "Checking Dockerfile..."
        if [ ! -f "Dockerfile.integrated" ]; then
          echo "âŒ Error: Dockerfile.integrated not found!"
          exit 1
        fi
        echo "âœ… Dockerfile.integrated exists"
        
        echo ""
        echo "Checking main_integrated.py..."
        if [ ! -f "main_integrated.py" ]; then
          echo "âŒ Error: main_integrated.py not found!"
          exit 1
        fi
        echo "âœ… main_integrated.py exists"
        
        echo ""
        echo "Checking requirements.txt..."
        if [ ! -f "requirements.txt" ]; then
          echo "âŒ Error: requirements.txt not found!"
          exit 1
        fi
        echo "âœ… requirements.txt exists"
        
        echo ""
        echo "Checking frontend build..."
        if [ ! -d "frontend-dist" ]; then
          echo "âŒ Error: frontend-dist directory not found!"
          exit 1
        fi
        if [ ! -f "frontend-dist/index.html" ]; then
          echo "âŒ Error: frontend-dist/index.html not found!"
          exit 1
        fi
        echo "âœ… frontend-dist/index.html exists"
        
        if [ -d "frontend-dist/assets" ]; then
          echo "âœ… frontend-dist/assets directory exists"
          ls -la frontend-dist/assets/ | head -5
        else
          echo "âš ï¸  Warning: frontend-dist/assets directory not found (may be empty)"
        fi
        
        echo ""
        echo "Checking app directory structure..."
        if [ ! -d "app" ]; then
          echo "âŒ Error: app directory not found!"
          exit 1
        fi
        echo "âœ… app directory exists"
        
        echo ""
        echo "All required files verified!"
        
        # Verify we're in the backend directory
        if [ ! -f "Dockerfile.integrated" ]; then
          echo "âŒ Error: Not in backend directory! Dockerfile.integrated not found in $(pwd)"
          echo "   Current directory contents: $(ls -la | head -10)"
          exit 1
        fi
        
        # OPTIMIZATION: Use ACR build with cache
        BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
        GIT_COMMIT="${{ github.sha }}"
        BUILD_VERSION="${{ github.run_number }}"
        
        echo "ğŸ”¨ Building Docker image (using ACR cache)..."
        echo "   Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        
        # ACR automatically caches layers - this speeds up builds significantly
        # Only changed layers are rebuilt (system deps, pip packages cached if unchanged)
        # Note: Removed --no-logs to see build output for debugging
        if ! az acr build \
          --registry ${{ env.ACR_NAME }} \
          --image ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
          --image ${{ env.IMAGE_NAME }}:latest \
          --file Dockerfile.integrated \
          --build-arg BUILD_DATE="$BUILD_DATE" \
          --build-arg GIT_COMMIT="$GIT_COMMIT" \
          --build-arg BUILD_VERSION="$BUILD_VERSION" \
          .; then
          echo ""
          echo "âŒ Docker build failed!"
          echo "   Check the logs above for the specific error"
          echo "   Common issues:"
          echo "   - Missing files (requirements.txt, main_integrated.py, etc.)"
          echo "   - Frontend build not found (frontend-dist/)"
          echo "   - Dockerfile syntax errors"
          echo "   - ACR authentication issues"
          echo "   - Dependencies not installed (check pip install logs)"
          exit 1
        fi
          
        echo "âœ… Docker image built and pushed to ACR"
        echo "   Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo "   Also tagged as: ${{ env.IMAGE_NAME }}:latest"
        echo "   Build Date: $BUILD_DATE"
        echo "   Git Commit: $GIT_COMMIT"
        
    - name: Get ACR credentials
      id: acr-creds
      run: |
        ACR_LOGIN=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer -o tsv)
        ACR_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
        ACR_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value -o tsv)
        
        echo "login_server=$ACR_LOGIN" >> $GITHUB_OUTPUT
        echo "username=$ACR_USER" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASS" >> $GITHUB_OUTPUT
        
    # OPTIMIZATION: Combine container config and app settings in one step
    - name: Configure App Service
      run: |
        echo "âš™ï¸  Configuring App Service..."
        
        # Configure container and force image pull in one command
        # Use new container config commands (non-deprecated)
        az webapp config container set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --container-image-name "${{ steps.acr-creds.outputs.login_server }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" \
          --container-registry-url "https://${{ steps.acr-creds.outputs.login_server }}" \
          --container-registry-user "${{ steps.acr-creds.outputs.username }}" \
          --container-registry-password "${{ steps.acr-creds.outputs.password }}" \
          --output none
        
        # Force image pull with timestamp
        az webapp config appsettings set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --settings \
            DOCKER_REGISTRY_SERVER_PASSWORD="${{ steps.acr-creds.outputs.password }}" \
            DOCKER_IMAGE_TAG="${{ env.IMAGE_TAG }}" \
            DEPLOYMENT_TIMESTAMP="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
          --output none
        
        echo "âœ… App Service configured"
        
    - name: Configure App Service settings
      run: |
        echo "âš™ï¸  Configuring App Service settings..."
        
        # Get Azure service credentials
        echo "ğŸ” Finding Azure resources..."
        STORAGE_ACCOUNT=$(az storage account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?contains(name, 'gait')].name" -o tsv | head -1)
        CV_NAME=$(az cognitiveservices account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?kind=='ComputerVision'].name" -o tsv | head -1)
        SQL_SERVER=$(az sql server list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?contains(name, 'gait')].name" -o tsv | head -1)
        
        echo "   Storage Account: ${STORAGE_ACCOUNT:-'NOT FOUND'}"
        echo "   Computer Vision: ${CV_NAME:-'NOT FOUND'}"
        echo "   SQL Server: ${SQL_SERVER:-'NOT FOUND'}"
        echo ""
        
        if [ -n "$STORAGE_ACCOUNT" ] && [ -n "$CV_NAME" ] && [ -n "$SQL_SERVER" ]; then
          echo "âœ… All Azure services found - configuring environment variables..."
          STORAGE_CONN=$(az storage account show-connection-string --name "$STORAGE_ACCOUNT" --resource-group ${{ env.RESOURCE_GROUP }} --query connectionString -o tsv)
          CV_KEY=$(az cognitiveservices account keys list --name "$CV_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query key1 -o tsv)
          CV_ENDPOINT=$(az cognitiveservices account show --name "$CV_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query properties.endpoint -o tsv)
          
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --settings \
              WEBSITES_PORT=8000 \
              CORS_ORIGINS="https://gentle-sky-0a498ab1e.4.azurestaticapps.net,https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net,http://localhost:3000,http://localhost:5173" \
              AZURE_STORAGE_CONNECTION_STRING="$STORAGE_CONN" \
              AZURE_STORAGE_CONTAINER_NAME="videos" \
              AZURE_COMPUTER_VISION_KEY="$CV_KEY" \
              AZURE_COMPUTER_VISION_ENDPOINT="$CV_ENDPOINT" \
              AZURE_SQL_SERVER="$SQL_SERVER.database.windows.net" \
              AZURE_SQL_DATABASE="gaitanalysis" \
              AZURE_SQL_USER="gaitadmin" \
              AZURE_SQL_PASSWORD="${{ secrets.AZURE_SQL_PASSWORD }}" \
            --output none
        else
          echo "âš ï¸  Some Azure services not found - setting basic configuration only"
          echo "   The app will run with mock services until Azure resources are created"
          echo ""
          # Set basic settings even if services don't exist
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --settings \
              WEBSITES_PORT=8000 \
              CORS_ORIGINS="https://gentle-sky-0a498ab1e.4.azurestaticapps.net,https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net,http://localhost:3000,http://localhost:5173" \
            --output none
        fi
        
        # Enable Always-On
        az webapp config set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --always-on true \
          --output none
        
        # HIGH AVAILABILITY: Configure for maximum availability
        echo "ğŸš€ Configuring high availability settings..."
        
        # Enable HTTP 2.0 for better performance
        az webapp config set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --http20-enabled true \
          --output none
        
        # Set health check path (using generic-configurations for newer API)
        az webapp config update \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --set healthCheckPath="/health" \
          --output none 2>/dev/null || echo "   (Health check may already be configured)"
        
        # Set request timeout via app settings (for long-running video processing and large file uploads)
        # WEBSITES_CONTAINER_START_TIME_LIMIT: Container startup timeout (default: 230s)
        # SCM_COMMAND_IDLE_TIMEOUT: SCM command timeout (default: 230s)
        # WEBSITES_HTTP_LOGGING_RETENTION_DAYS: Log retention (optional)
        # CRITICAL: Azure App Service has a default request timeout of 230 seconds
        # For large video uploads, we need to increase this via web.config or app settings
        # Note: The actual request timeout is controlled by Azure's load balancer (230s default)
        # We can't change it via app settings, but we can optimize the upload process
        az webapp config appsettings set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --settings \
            WEBSITES_WORKER_PROCESSES=1 \
            WEBSITES_CONTAINER_START_TIME_LIMIT=600 \
            SCM_COMMAND_IDLE_TIMEOUT=600 \
          --output none
        
        # CRITICAL: Configure request timeout via web.config
        # Azure App Service uses web.config to set request timeout
        # This allows large file uploads to complete without timing out
        echo "ğŸ“ Configuring request timeout for large file uploads..."
        az webapp config set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --generic-configurations '{"requestTimeout": "00:10:00"}' \
          --output none || echo "âš ï¸  Could not set request timeout (may require web.config file)"
        
        echo "âœ… High availability settings configured"
        
    - name: Restart App Service
      run: |
        echo "ğŸ”„ Starting App Service with new container..."
        az webapp start \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --output none
        
        echo "âœ… App Service started"
        echo "â³ Waiting 10 seconds for initial startup..."
        sleep 10
        
        # Verify the app is running
        STATE=$(az webapp show \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query state -o tsv)
        echo "   App Service state: $STATE"
        
        if [ "$STATE" != "Running" ]; then
          echo "âš ï¸  App Service is not in Running state, attempting restart..."
          az webapp restart \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --output none
          sleep 30
        fi
        
    # OPTIMIZATION: Reduced wait time - health check will handle readiness
    - name: Wait for container startup
      run: sleep 10
        
    # OPTIMIZATION: Removed redundant verification - health check covers this
    
    - name: Health check
      continue-on-error: true
      run: |
        echo "ğŸ§ª Health check..."
        APP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        
        HEALTH_CHECK_PASSED=false
        # OPTIMIZATION: Reduced to 6 checks * 3s = max 18s (was 10 * 5s = 50s)
        for i in {1..6}; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$APP_URL/health" 2>/dev/null || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Application is healthy!"
            HEALTH_CHECK_PASSED=true
            break
          else
            echo "   Check $i/6... HTTP $HTTP_CODE"
            [ "$i" -lt 6 ] && sleep 3
          fi
        done
        
        if [ "$HEALTH_CHECK_PASSED" = "false" ]; then
          echo "âš ï¸  Health check timeout (app may still be starting)"
          echo "   Check logs: az webapp log tail --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }}"
          # Don't fail - app may still be starting
        fi

    - name: Deployment summary
      if: always()
      run: |
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“Š DEPLOYMENT SUMMARY"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "ğŸ”— Application URL:"
        echo "   https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        echo ""
        echo "ğŸ“¦ Docker Image:"
        echo "   ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo ""
        echo "ğŸ” Azure Resources:"
        echo "   Resource Group: ${{ env.RESOURCE_GROUP }}"
        echo "   App Service: ${{ env.AZURE_WEBAPP_NAME }}"
        echo "   ACR: ${{ env.ACR_NAME }}"
        echo ""
        echo "ğŸ“ Useful Commands:"
        echo "   View logs: az webapp log tail --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }}"
        echo "   Check status: az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query state"
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""


