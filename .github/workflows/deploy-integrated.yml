name: Deploy Integrated App (Frontend + Backend)

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'frontend/**'
      - '.github/workflows/deploy-integrated.yml'
      - 'scripts/deploy-integrated-app.sh'
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: gaitanalysisapp
  RESOURCE_GROUP: gait-analysis-rg-wus3
  ACR_NAME: gaitacr737
  IMAGE_NAME: gait-integrated
  IMAGE_TAG: ${{ github.sha }}
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Check if frontend changed
      id: frontend-changed
      run: |
        # Check if frontend files changed in this commit
        # Use HEAD^ for push events, or check changed files from workflow trigger
        if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ]; then
          if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -q "^frontend/"; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "âœ… Frontend files changed - will rebuild"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "â­ï¸  Frontend unchanged - will use cached build if available"
          fi
        else
          # For workflow_dispatch or if before is not available, check if frontend files exist and are recent
          if [ -d "frontend" ] && [ -f "frontend/package.json" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "âœ… Frontend detected - will rebuild (manual trigger or first run)"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "â­ï¸  No frontend directory - skipping frontend build"
          fi
        fi
    
    - name: Set up Node.js
      if: steps.frontend-changed.outputs.changed == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Build frontend
      if: steps.frontend-changed.outputs.changed == 'true'
      run: |
        echo "ğŸ“¦ Building frontend..."
        cd frontend
        
        # Check if package.json exists
        if [ ! -f "package.json" ]; then
          echo "âŒ Error: package.json not found!"
          exit 1
        fi
        
        # Install dependencies
        echo "ğŸ“¥ Installing dependencies..."
        npm ci || {
          echo "âŒ Error: npm ci failed!"
          echo "   Trying npm install as fallback..."
          npm install || exit 1
        }
        
        # Build frontend
        echo "ğŸ”¨ Building frontend..."
        npm run build || {
          echo "âŒ Error: Frontend build failed!"
          echo "   Check the build logs above for details"
          exit 1
        }
        
        # Verify build output
        if [ ! -d "dist" ]; then
          echo "âŒ Error: Frontend build output (dist/) not found!"
          exit 1
        fi
        if [ ! -f "dist/index.html" ]; then
          echo "âŒ Error: dist/index.html not found!"
          exit 1
        fi
        
        echo "âœ… Frontend built successfully"
        
    - name: Copy frontend to backend
      if: steps.frontend-changed.outputs.changed == 'true'
      run: |
        echo "ğŸ“‹ Copying frontend build to backend..."
        rm -rf backend/frontend-dist
        cp -r frontend/dist backend/frontend-dist
        echo "âœ… Frontend copied to backend/frontend-dist"
    
    - name: Use cached frontend build
      if: steps.frontend-changed.outputs.changed == 'false'
      run: |
        echo "â­ï¸  Frontend unchanged - checking for existing build..."
        if [ -d "backend/frontend-dist" ] && [ -f "backend/frontend-dist/index.html" ]; then
          echo "âœ… Using existing frontend build in backend/frontend-dist"
        else
          echo "âš ï¸  No cached frontend build found - will need to build"
          echo "   This shouldn't happen, but continuing..."
        fi
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        cache-dependency-path: backend/requirements.txt
        
    - name: Log in to Azure
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Verify Azure resources exist
      run: |
        echo "ğŸ” Verifying Azure resources..."
        
        # Check Resource Group
        if ! az group show --name ${{ env.RESOURCE_GROUP }} &>/dev/null; then
          echo "âŒ Error: Resource group '${{ env.RESOURCE_GROUP }}' not found!"
          exit 1
        fi
        echo "âœ… Resource group exists"
        
        # Check App Service
        if ! az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
          echo "âŒ Error: App Service '${{ env.AZURE_WEBAPP_NAME }}' not found!"
          exit 1
        fi
        echo "âœ… App Service exists"
        
        # Check ACR
        if ! az acr show --name ${{ env.ACR_NAME }} &>/dev/null; then
          echo "âŒ Error: ACR '${{ env.ACR_NAME }}' not found!"
          exit 1
        fi
        echo "âœ… ACR exists"
        
        echo "âœ… All Azure resources verified"
        
    - name: Log in to Azure Container Registry
      run: |
        az acr login --name ${{ env.ACR_NAME }}
        
    - name: Verify Dockerfile exists
      run: |
        if [ ! -f "backend/Dockerfile.integrated" ]; then
          echo "âŒ Error: Dockerfile.integrated not found!"
          exit 1
        fi
        echo "âœ… Dockerfile.integrated found"
        
    - name: Verify frontend build exists
      run: |
        if [ ! -d "backend/frontend-dist" ]; then
          echo "âŒ Error: frontend-dist directory not found!"
          exit 1
        fi
        if [ ! -f "backend/frontend-dist/index.html" ]; then
          echo "âŒ Error: frontend-dist/index.html not found!"
          exit 1
        fi
        echo "âœ… Frontend build verified"
        
    - name: Verify cleaned code before build
      continue-on-error: true
      run: |
        echo "ğŸ” Verifying cleaned code structure..."
        cd backend
        
        # Verify old files are deleted (non-blocking - just a warning)
        if [ -f "app/api/v1/analysis.py" ]; then
          echo "âš ï¸  Warning: Old analysis.py still exists (non-blocking)"
        fi
        if [ -f "app/api/v1/health.py" ]; then
          echo "âš ï¸  Warning: Old health.py still exists (non-blocking)"
        fi
        if [ -f "app/api/v1/reports.py" ]; then
          echo "âš ï¸  Warning: Old reports.py still exists (non-blocking)"
        fi
        
        # Verify __init__.py doesn't import old files
        if grep -q "from app.api.v1 import analysis, health, reports" app/api/v1/__init__.py 2>/dev/null; then
          echo "âš ï¸  Warning: __init__.py may import deleted files (non-blocking)"
        fi
        
        # Verify only Azure-native files exist
        echo "âœ… Code structure verified (warnings are non-blocking)"
        
    - name: Build and push Docker image to ACR
      run: |
        echo "ğŸ³ Building Docker image (Frontend + Backend)..."
        
        # Verify backend directory exists and change to it
        echo "ğŸ“‚ Checking working directory..."
        echo "   Current directory: $(pwd)"
        echo "   Contents: $(ls -d */ 2>/dev/null | head -5 || echo 'No subdirectories')"
        
        if [ ! -d "backend" ]; then
          echo "âŒ Error: backend directory not found!"
          echo "   Current directory: $(pwd)"
          echo "   Full contents:"
          ls -la
          exit 1
        fi
        
        echo "âœ… backend directory found"
        cd backend || {
          echo "âŒ Error: Failed to change to backend directory"
          echo "   Current directory: $(pwd)"
          exit 1
        }
        
        echo "âœ… Changed to backend directory: $(pwd)"
        
        # Verify required files exist
        echo "ğŸ“‹ Verifying required files..."
        echo ""
        echo "Checking Dockerfile..."
        if [ ! -f "Dockerfile.integrated" ]; then
          echo "âŒ Error: Dockerfile.integrated not found!"
          exit 1
        fi
        echo "âœ… Dockerfile.integrated exists"
        
        echo ""
        echo "Checking main_integrated.py..."
        if [ ! -f "main_integrated.py" ]; then
          echo "âŒ Error: main_integrated.py not found!"
          exit 1
        fi
        echo "âœ… main_integrated.py exists"
        
        echo ""
        echo "Checking requirements.txt..."
        if [ ! -f "requirements.txt" ]; then
          echo "âŒ Error: requirements.txt not found!"
          exit 1
        fi
        echo "âœ… requirements.txt exists"
        
        echo ""
        echo "Checking frontend build..."
        if [ ! -d "frontend-dist" ]; then
          echo "âŒ Error: frontend-dist directory not found!"
          exit 1
        fi
        if [ ! -f "frontend-dist/index.html" ]; then
          echo "âŒ Error: frontend-dist/index.html not found!"
          exit 1
        fi
        echo "âœ… frontend-dist/index.html exists"
        
        if [ -d "frontend-dist/assets" ]; then
          echo "âœ… frontend-dist/assets directory exists"
          ls -la frontend-dist/assets/ | head -5
        else
          echo "âš ï¸  Warning: frontend-dist/assets directory not found (may be empty)"
        fi
        
        echo ""
        echo "Checking app directory structure..."
        if [ ! -d "app" ]; then
          echo "âŒ Error: app directory not found!"
          exit 1
        fi
        echo "âœ… app directory exists"
        
        echo ""
        echo "All required files verified!"
        
        # Verify we're in the backend directory
        if [ ! -f "Dockerfile.integrated" ]; then
          echo "âŒ Error: Not in backend directory! Dockerfile.integrated not found in $(pwd)"
          echo "   Current directory contents: $(ls -la | head -10)"
          exit 1
        fi
        
        # Build image using ACR Tasks
        echo "ğŸ”¨ Starting Docker build..."
        echo "   Registry: ${{ env.ACR_NAME }}"
        echo "   Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo "   Dockerfile: Dockerfile.integrated"
        echo "   Working directory: $(pwd)"
        echo ""
        
        # Set build arguments for traceability
        BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
        GIT_COMMIT="${{ github.sha }}"
        BUILD_VERSION="${{ github.run_number }}"
        
        echo "ğŸ“¦ Build information:"
        echo "   Build Date: $BUILD_DATE"
        echo "   Git Commit: $GIT_COMMIT"
        echo "   Build Version: $BUILD_VERSION"
        echo ""
        
        # Use ACR build cache for faster builds
        # ACR automatically caches Docker layers - unchanged layers are reused
        # This significantly speeds up builds when only code changes
        # System deps and pip packages are cached if requirements.txt unchanged
        if ! az acr build \
          --registry ${{ env.ACR_NAME }} \
          --image ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
          --image ${{ env.IMAGE_NAME }}:latest \
          --file Dockerfile.integrated \
          --build-arg BUILD_DATE="$BUILD_DATE" \
          --build-arg GIT_COMMIT="$GIT_COMMIT" \
          --build-arg BUILD_VERSION="$BUILD_VERSION" \
          .; then
          echo ""
          echo "âŒ Docker build failed!"
          echo "   Check the logs above for the specific error"
          echo "   Common issues:"
          echo "   - Missing files (requirements.txt, main_integrated.py, etc.)"
          echo "   - Frontend build not found (frontend-dist/)"
          echo "   - Dockerfile syntax errors"
          echo "   - ACR authentication issues"
          exit 1
        fi
          
        echo "âœ… Docker image built and pushed to ACR"
        echo "   Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo "   Also tagged as: ${{ env.IMAGE_NAME }}:latest"
        echo "   Build Date: $BUILD_DATE"
        echo "   Git Commit: $GIT_COMMIT"
        
    - name: Get ACR credentials
      id: acr-creds
      run: |
        ACR_LOGIN=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer -o tsv)
        ACR_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
        ACR_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value -o tsv)
        
        echo "login_server=$ACR_LOGIN" >> $GITHUB_OUTPUT
        echo "username=$ACR_USER" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASS" >> $GITHUB_OUTPUT
        
    - name: Configure App Service container
      run: |
        echo "âš™ï¸  Configuring App Service container..."
        echo "   Using image: ${{ steps.acr-creds.outputs.login_server }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        
        # Stop the app first to ensure clean restart
        echo "ğŸ›‘ Stopping App Service..."
        az webapp stop \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --output none || echo "   (App may already be stopped)"
        
        # Configure container with new image
        az webapp config container set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --docker-custom-image-name "${{ steps.acr-creds.outputs.login_server }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" \
          --docker-registry-server-url "https://${{ steps.acr-creds.outputs.login_server }}" \
          --docker-registry-server-user "${{ steps.acr-creds.outputs.username }}" \
          --docker-registry-server-password "${{ steps.acr-creds.outputs.password }}" \
          --output none
        
        # Also set password via app settings (backup method)
        az webapp config appsettings set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --settings DOCKER_REGISTRY_SERVER_PASSWORD="${{ steps.acr-creds.outputs.password }}" \
          --output none
        
        echo "âœ… Container configuration updated"
        
        # Force container to pull new image by setting an environment variable
        # This ensures Azure pulls the latest image even if tag is 'latest'
        echo "ğŸ”„ Forcing container to pull new image..."
        az webapp config appsettings set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --settings \
            DOCKER_IMAGE_TAG="${{ env.IMAGE_TAG }}" \
            DEPLOYMENT_TIMESTAMP="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
          --output none
        
        echo "âœ… Image pull forced with deployment timestamp"
        
    - name: Configure App Service settings
      run: |
        echo "âš™ï¸  Configuring App Service settings..."
        
        # Get Azure service credentials
        echo "ğŸ” Finding Azure resources..."
        STORAGE_ACCOUNT=$(az storage account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?contains(name, 'gait')].name" -o tsv | head -1)
        CV_NAME=$(az cognitiveservices account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?kind=='ComputerVision'].name" -o tsv | head -1)
        SQL_SERVER=$(az sql server list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?contains(name, 'gait')].name" -o tsv | head -1)
        
        echo "   Storage Account: ${STORAGE_ACCOUNT:-'NOT FOUND'}"
        echo "   Computer Vision: ${CV_NAME:-'NOT FOUND'}"
        echo "   SQL Server: ${SQL_SERVER:-'NOT FOUND'}"
        echo ""
        
        if [ -n "$STORAGE_ACCOUNT" ] && [ -n "$CV_NAME" ] && [ -n "$SQL_SERVER" ]; then
          echo "âœ… All Azure services found - configuring environment variables..."
          STORAGE_CONN=$(az storage account show-connection-string --name "$STORAGE_ACCOUNT" --resource-group ${{ env.RESOURCE_GROUP }} --query connectionString -o tsv)
          CV_KEY=$(az cognitiveservices account keys list --name "$CV_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query key1 -o tsv)
          CV_ENDPOINT=$(az cognitiveservices account show --name "$CV_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query properties.endpoint -o tsv)
          
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --settings \
              WEBSITES_PORT=8000 \
              CORS_ORIGINS="https://gentle-sky-0a498ab1e.4.azurestaticapps.net,https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net,http://localhost:3000,http://localhost:5173" \
              AZURE_STORAGE_CONNECTION_STRING="$STORAGE_CONN" \
              AZURE_STORAGE_CONTAINER_NAME="videos" \
              AZURE_COMPUTER_VISION_KEY="$CV_KEY" \
              AZURE_COMPUTER_VISION_ENDPOINT="$CV_ENDPOINT" \
              AZURE_SQL_SERVER="$SQL_SERVER.database.windows.net" \
              AZURE_SQL_DATABASE="gaitanalysis" \
              AZURE_SQL_USER="gaitadmin" \
              AZURE_SQL_PASSWORD="${{ secrets.AZURE_SQL_PASSWORD }}" \
            --output none
        else
          echo "âš ï¸  Some Azure services not found - setting basic configuration only"
          echo "   The app will run with mock services until Azure resources are created"
          echo ""
          # Set basic settings even if services don't exist
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --settings \
              WEBSITES_PORT=8000 \
              CORS_ORIGINS="https://gentle-sky-0a498ab1e.4.azurestaticapps.net,https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net,http://localhost:3000,http://localhost:5173" \
            --output none
        fi
        
        # Enable Always-On
        az webapp config set \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --always-on true \
          --output none
          
        echo "âœ… App Service settings configured"
        
    - name: Restart App Service
      run: |
        echo "ğŸ”„ Starting App Service with new container..."
        az webapp start \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --output none
        
        echo "âœ… App Service started"
        echo "â³ Waiting 15 seconds for initial startup..."
        sleep 15
        
        # Verify the app is running
        STATE=$(az webapp show \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query state -o tsv)
        echo "   App Service state: $STATE"
        
        if [ "$STATE" != "Running" ]; then
          echo "âš ï¸  App Service is not in Running state, attempting restart..."
          az webapp restart \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --output none
          sleep 30
        fi
        
    - name: Wait for container to be ready
      run: |
        echo "â³ Waiting for container to be fully ready..."
        echo "   This may take 30-60 seconds for the first request"
        sleep 30
        
    - name: Verify deployed code
      run: |
        echo "ğŸ” Verifying deployed code..."
        APP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        
        # Check if we can get a response (even if 500, means code is running)
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$APP_URL/" || echo "000")
        echo "   Initial response: HTTP $HTTP_CODE"
        
        if [ "$HTTP_CODE" = "000" ]; then
          echo "   âš ï¸  App not responding yet, will retry in health check"
        else
          echo "   âœ… App is responding (code may still be deploying)"
        fi
    
    - name: Health check
      continue-on-error: true
      run: |
        echo "ğŸ§ª Testing application health..."
        APP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        
        echo "ğŸ“ Testing endpoints:"
        echo "   - $APP_URL/"
        echo "   - $APP_URL/health"
        echo ""
        
        HEALTH_CHECK_PASSED=false
        LAST_ERROR=""
        # Reduced from 25 to 15 checks (2 minutes instead of 3+ minutes)
        for i in {1..15}; do
          # Test root endpoint
          HTTP_CODE_ROOT=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 "$APP_URL/" 2>&1 | tail -1 || echo "000")
          # Test health endpoint  
          HTTP_CODE_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 "$APP_URL/health" 2>&1 | tail -1 || echo "000")
          
          # Check for specific error patterns in response
          RESPONSE=$(curl -s --max-time 15 "$APP_URL/" 2>&1 || echo "")
          ERROR_RESPONSE=$(curl -s --max-time 15 "$APP_URL/health" 2>&1 || echo "")
          
          # Detect common deployment errors
          if echo "$RESPONSE $ERROR_RESPONSE" | grep -qi "FileResponse.*not defined\|NameError.*FileResponse"; then
            LAST_ERROR="FileResponse import missing - deployment may not have updated. Code needs to be rebuilt."
            echo "   âŒ Check $i/25... Found FileResponse error - code may not be updated"
            echo "   This indicates the old code is still running. The new image may not have been pulled."
            if [ "$i" -eq 5 ]; then
              echo "   ğŸ”„ Attempting to force container restart..."
              az webapp restart \
                --name ${{ env.AZURE_WEBAPP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --output none
              sleep 20
            fi
          elif echo "$RESPONSE $ERROR_RESPONSE" | grep -qi "500\|Internal Server Error"; then
            if [ -z "$LAST_ERROR" ]; then
              LAST_ERROR="Application error detected (HTTP 500)"
            fi
            echo "   âš ï¸  Check $i/25... Application error (HTTP $HTTP_CODE_ROOT)"
          elif [ "$HTTP_CODE_ROOT" = "200" ] || [ "$HTTP_CODE_HEALTH" = "200" ]; then
            echo ""
            echo "âœ…âœ…âœ… Application is healthy!"
            echo "   Root endpoint: HTTP $HTTP_CODE_ROOT"
            echo "   Health endpoint: HTTP $HTTP_CODE_HEALTH"
            echo ""
            
            # Show health check details
            curl -s --max-time 15 "$APP_URL/health" | python3 -m json.tool 2>/dev/null || \
            curl -s --max-time 15 "$APP_URL/" | python3 -m json.tool 2>/dev/null || \
            echo "   (Response received but not JSON)"
            
            echo ""
            echo "ğŸ”— Application URL: $APP_URL"
            echo "âœ… Integrated deployment successful!"
            HEALTH_CHECK_PASSED=true
            break
          else
            echo "   Check $i/25... (Root: $HTTP_CODE_ROOT, Health: $HTTP_CODE_HEALTH)"
            if [ "$i" -eq 10 ]; then
              echo "   â³ Still starting... this is normal, container may need more time"
            fi
            if [ "$i" -eq 20 ]; then
              echo "   â³ Taking longer than expected... checking logs may help"
            fi
            sleep 8
          fi
        done
        
        if [ "$HEALTH_CHECK_PASSED" = "false" ]; then
          echo ""
          echo "âš ï¸  Application health check did not pass within timeout"
          echo "   Final status: Root=$HTTP_CODE_ROOT, Health=$HTTP_CODE_HEALTH"
          if [ -n "$LAST_ERROR" ]; then
            echo "   Error detected: $LAST_ERROR"
          fi
          echo ""
          echo "   This may indicate:"
          echo "   - Container is still starting (wait 2-3 more minutes)"
          echo "   - Code deployment issue (check if new code is in image)"
          echo "   - Application error (check logs below)"
          echo ""
          echo "   Check Azure Portal logs:"
          echo "   https://portal.azure.com/#@/resource/subscriptions/*/resourceGroups/${{ env.RESOURCE_GROUP }}/providers/Microsoft.Web/sites/${{ env.AZURE_WEBAPP_NAME }}/logStream"
          echo ""
          echo "   Or check logs with:"
          echo "   az webapp log tail --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }}"
          exit 1
        fi

    - name: Deployment summary
      if: always()
      run: |
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“Š DEPLOYMENT SUMMARY"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "ğŸ”— Application URL:"
        echo "   https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        echo ""
        echo "ğŸ“¦ Docker Image:"
        echo "   ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo ""
        echo "ğŸ” Azure Resources:"
        echo "   Resource Group: ${{ env.RESOURCE_GROUP }}"
        echo "   App Service: ${{ env.AZURE_WEBAPP_NAME }}"
        echo "   ACR: ${{ env.ACR_NAME }}"
        echo ""
        echo "ğŸ“ Useful Commands:"
        echo "   View logs: az webapp log tail --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }}"
        echo "   Check status: az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query state"
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""


